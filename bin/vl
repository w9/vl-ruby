#!/usr/bin/env ruby

#TODO: add column colors
#TODO: chop long columns (option)

begin

require 'optparse'
require 'colorize'
require 'csv'

$options = {
  :padding => 1,
  :quote => '"',
  :skip => 0,
  :comment => /^#/,
  :probe_lines => 100,
  :justify => 'l',
  :alternate_color => false,
  :chop_length => 1024,
}



opts = OptionParser.new do |opts|
  opts.set_banner ''
  opts.set_summary_indent '    '
  opts.set_summary_width 28

  opts.separator '/==============================================================================\\'
  opts.separator ''
  opts.separator '  (' + 'V'.bold.blue + ')iew (' + 'L'.bold.yellow + ')arge table: lightning fast table formatter'
  opts.separator ''
  opts.separator '  output to stdout: ' + 'vl FILENAME [options]'.green
  opts.separator '  pipe to less: ' + 'vll FILENAME [options]'.green
  opts.separator ''
  opts.separator '  Options:'

  opts.on('-s', '--separator <REGEX>', 'char or string to match the separator [\t]') do |s|
    begin
      options[:separator] = Regexp.new(s)
    rescue
      puts 'Warning: Problems encountered when processing the regex.'
      puts "Warning: Default value \"#{$options[:separator].source}\" is used."
    end
  end

  opts.on('-p', '--padding <INT>', 'number of spaces that separate the columns [1]') do |p|
    $options[:padding] = p.to_i
  end

  opts.on('-k', '--skip <INT>', 'number of top lines to skip [0]') do |k|
    $options[:skip] = k.to_i
  end

  opts.on('-g', '--probe-lines <INT>', 'number of top lines used for estimation [100]') do |p|
    $options[:probe_lines] = p.to_i
  end

  opts.on('-j', '--justify {l|r|a}', 'justification mode for cells (l/r/a) [l]') do |j|
    if ['l', 'r', 'a'].include?(j[0])
      $options[:justify] = j[0]
    else
      puts 'Warning: Unrecognized justify option.'
      puts "Warning: Default value \"#{$options[:justify]}\" is used"
    end
  end
          
  opts.on('-c', '--comment <REGEX>', 'regex to match lines to ignore [^#]') do |c|
    begin
      $options[:comment] = Regexp.new(c)
    rescue
      STDERR.puts 'Warning: Problems encountered when processing the regex.'
      STDERR.puts "Warning: Default value \"#{$options[:comment].source}\" is used."
    end
  end

  opts.on('-q', '--quote <CHAR>', 'character of quote [\x00]') do |q|
    $options[:quote] = q
  end

  opts.on('-z', '--[no-]alternative-color', 'use alternative colors [no]') do |c|
    $options[:alternate_color] = c
  end

  opts.on('-l', '--chop-length <INT>', 'chop columns longer than this length [1024]') do |l|
    $options[:chop_length] = l.to_i
  end

  opts.separator ''
  opts.separator '\==============================================================================/'
  opts.separator ''
end

opts.parse!


if !$options[:separator]
  if ARGF.filename =~ /.*\.csv/
    $options[:separator] = ','
  else
    $options[:separator] = "\t"
  end
end

if !$options[:quote]
  if ARGF.filename =~ /.*\.csv/
    $options[:quote] = '"'
  else
    $options[:quote] = "\x00"
  end
end


#------#
# Main #
#------#


$max_widths = []

#==== line caching ====#
cached_lines = []
ARGF.each_line.with_index.reduce 0 do |pnum, (line, lnum)|
  cached_lines.push(line)
  next pnum if lnum < $options[:skip] or line =~ $options[:comment]
  parsed_line = CSV.parse_line(line, {:col_sep=>$options[:separator], :quote_char=>$options[:quote]})
  # damn you, 'csv' package!
  parsed_line = [] if parsed_line == nil
  parsed_line.each_with_index do |c, i|
    # damn you, 'csv' package!
    c = '' if c == nil
    c = c.inspect[1..-2]
    # -1 because it's possible that c is empty and i is out of range
    if $max_widths.fetch(i, -1) < c.length then $max_widths[i] = c.length end
  end
  (pnum += 1) < $options[:probe_lines] ? pnum : break
end
#======================#


def print_line(line, lnum)
  if lnum < $options[:skip] or line =~ $options[:comment] then
    print line
    return
  end
  parsed_line = CSV.parse_line(line, {:col_sep=>$options[:separator], :quote_char=>$options[:quote]})
  # damn you, 'csv' package!
  parsed_line = [] if parsed_line == nil
  parsed_line.each_with_index do |c, i|
    # damn you, 'csv' package!
    c = '' if c == nil
    c = c.inspect[1..-2]

    if $max_widths.fetch(i, -1) < c.length then
      $max_widths[i] = c.length
    end

    c = c[0..$options[:chop_length]]
    $max_widths[i] = [$options[:chop_length], $max_widths[i]].min

    case $options[:justify]
      when 'l'
        c = c.ljust($max_widths[i] + $options[:padding]) rescue break
      when 'r'
        c = c.rjust($max_widths[i] + $options[:padding]) rescue break
      when 'a'
        begin
          if Float(c) then c = c.rjust($max_widths[i] + $options[:padding]) end
        rescue
          c = c.ljust($max_widths[i] + $options[:padding])
        end
      end

    if $options[:alternate_color] then
      c = c.colorize([:yellow, :blue][i % 2])
    end

    print c
  end
  puts
rescue
  STDERR.puts 'vl: Pipe ended while writing.'
  abort
end

cached_lines.each.with_index do |line, lnum|
  print_line(line, lnum)
end

ARGF.each_line.with_index do |line, lnum|
  print_line(line, lnum)
end




rescue Interrupt

end
